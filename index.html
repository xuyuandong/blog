
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Mr X&#8217;s blog</title>
  <meta name="author" content="XuYuandong">

  
  <meta name="description" content="《Scalable Web Architecture and Distributed System》简译 网站分布式系统设计原则 可用性
主要是容错和错误恢复。不能因为个别服务器宕机而影响用户访问。 高性能
快速响应与低延迟。对关乎用户体验和广告收入的系统尤为重要。 可靠性
读写一致性与持久性。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://xuyuandong.github.io/blog">
  <link href="/blog/favicon.png" rel="icon">
  <link href="/blog/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/blog/atom.xml" rel="alternate" title="Mr X's blog" type="application/atom+xml">
  <script src="/blog/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/blog/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/blog/">Mr X&#8217;s blog</a></h1>
  
    <h2>Taste the life and figure out the meaning</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/blog/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:xuyuandong.github.io/blog" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/blog/">Blog</a></li>
  <li><a href="/blog/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2014/11/10/scalable-web-systems/">可扩展网站架构与分布式系统</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-10T17:27:12+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>5:27 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><em>《Scalable Web Architecture and Distributed System》简译</em></p>

<p><strong>网站分布式系统设计原则</strong></p>

<p><em>可用性</em>
主要是容错和错误恢复。不能因为个别服务器宕机而影响用户访问。</p>

<p><em>高性能</em>
快速响应与低延迟。对关乎用户体验和广告收入的系统尤为重要。</p>

<p><em>可靠性</em>
读写一致性与持久性。当系统数据发生变化，请求应该返回最新的数据；当用户使用系统时，能够保证写入的数据在未来是不会丢失的。</p>

<p><em>扩展性</em>
为处理更大的流量或存储需求，而能够方便的增加服务器。</p>

<p><em>操控性</em>
易于管理、维护、修改或升级系统的功能。</p>

<p><em>低成本</em>
所有开发、运维、机器、人员、和培训的成本之和。</p>

<p><strong>基本知识</strong></p>

<p>设计系统架构时，有几点是一定要考虑的，如有哪些模块、他们如何组织起来、彼此间要做哪些trade off。这里举了一个例子来阐述这些核心的因素，包括服务、冗余、划分、错误处理等。</p>

<p><em>例：图片存取服务网站</em></p>

<p>想象要建设这样一个系统，用户可以上传图片到中心服务器，图片会通过web链接或者API（类似Flickr或Picasa）被请求。为了简单起见，我们把问题简化为两部分，上传图片和请求查看图片。我们希望上传速度要快，但我们常常更注重请求查看图片的响应效率，这一点可以被CDN服务所证明。</p>

<p>系统其他比较重要的方面包括：<br/>
1. 对系统存储图片的数量是无限制的，图片存储要由扩展能力。<br/>
2. 下载图片要有较低延迟。<br/>
3. 如果用户上传图片，图片需要被永久保存起来不会丢失，并随时可以被访问到。<br/>
4. 系统应该容易被管理和操作。<br/>
5. 系统应该有较低的成本，比较图片服务网站没有多少利润。</p>

<p><img src="http://www.aosabook.org/images/distsys/imageHosting1.jpg" title="Figure 1.1: Simplified architecture diagram for image hosting application" alt="Figure 1.1: Simplified architecture diagram for image hosting application" /></p>

<p><em>服务</em></p>

<p>首先，需要考虑将各个系统功能解耦合，每一部分定义自己的清晰的服务接口，这就是我们常说的Service-Oriented Architecture (SOA)，典型的做法是定义公共的抽象的API。在我们的问题中，主要是上传和获取图片这两部分服务的分离。</p>

<p>此外，我们可以发现图片写入的速度和时间其实会对图片读取效率有影响，因为两者要共享资源，所以这个影响是巨大的。即使上传和下载速度一样（这在大部分IP网络中是不可能的，一般下载和上传网速比约为3:1），读文件经常会读缓存，而写文件会写入磁盘（为保证最终一致性还可能多次），因此数据的写总是会更慢一些。(Pole Position, an open source tool for DB benchmarking, <a href="http://polepos.org/">http://polepos.org/</a> and results <a href="http://polepos.sourceforge.net/results/PolePositionClientServer.pdf.">http://polepos.sourceforge.net/results/PolePositionClientServer.pdf.</a>).</p>

<p>另一个架构设计问题是web服务器（Apach、lighttpd）对并发连接数的限制（default=500），在流量高峰时，写连接经常会耗尽这些资源（想象一下上传1M图片，持续时间超过一秒，不能异步返回的情况）。面对这种情况，最好就是将读写服务分离，这允许我们独立扩展这两部分，并方便对各自做效率优化、问题调试、以及扩展，参考Figure1.2。</p>

<p><img src="http://www.aosabook.org/images/distsys/imageHosting2.png" title="Figure 1.2: Splitting out reads and writes" alt="Figure 1.2: Splitting out reads and writes" /></p>

<p>举个例子，Flickr解决读写问题是通过将用户做水平划分（sharding），用户增加是可以向集群增加更多的shards (see the presentation on Flickr&rsquo;s scaling, <a href="http://mysqldba.blogspot.com/2008/04/mysql-uc-2007-presentation-file.html">http://mysqldba.blogspot.com/2008/04/mysql-uc-2007-presentation-file.html</a>)。产生的代价就是对系统的更新只能一个个shard进行（系统不在是一个整体），增加了运维的复杂度，谈及这个方面没有标准的解决方案，一切都要根据上一节的几项原则找到最佳的trade off。</p>

<p><em>冗余</em></p>

<p>为了有效应对系统宕机等错误，架构上必须对服务和数据做冗余处理。例如，文件需要存储多发，服务和应用也要部署多个备份或多个版本，避免单点故障。
服务冗余的另一个重要性在于创建了一个shared nothing系统，即是每个节点都可独立运转，整体上形成了去中心化，这对提高扩展性是很有帮助的。下图Figure 1.3表现了图片系统的冗余处理:</p>

<p><img src="http://www.aosabook.org/images/distsys/imageHosting3.png" title="Figure 1.3: Image hosting application with redundancy" alt="Figure 1.3: Image hosting application with redundancy" /></p>

<p><em>划分</em></p>

<p>当数据量不能由单机进行存储，或某些操作需要大量计算资源时，增加存储或计算能力是必须的，这里有两种选择：垂直扩展或水平扩展。</p>

<p>垂直扩展还是扩充单机的性能，如增加磁盘、增加CPU和内存。水平扩展是指增加更多节点，如将数据做划分，每个节点只存储部分数据。</p>

<p>当使用水平扩展时，通用的技术是将服务做partitons/shards。划分准则是多样的，主要考虑划为不同的逻辑功能集合，比如将服务按地理边界划分。在我们的图片服务中，可以把图片存储在多个文件服务器中，每个服务器处理独一无二的图片集合，存储不够就加服务器。这样的设计需要一个命名策略把文件名和具体存储机器关联起来，比如一致性哈希策略，或者为每个图片赋予一个自增的ID，每个服务器关联一段区域范围的ID（有点像索引）。</p>

<p><img src="http://www.aosabook.org/images/distsys/imageHosting4.png" title="Figure 1.4: Image hosting application with redundancy and partitioning" alt="Figure 1.4: Image hosting application with redundancy and partitioning" /></p>

<p>分布式进行数据存储或运算是有挑战的，一个关键问题就是数据的局部性(locality)，操作离数据约近，效率越高，但分布式系统却强制通过网络来获取所需的数据。另一个问题是不一致性(inconsistency)，当不同服务同时读和写一个共享资源时，可能出现竞争条件。</p>

<p>划分数据的确会带来一定问题，但是它允许每个问题通过数据、负载、使用模式划整为零，变得易于扩展，但是如何处理引入的风险和错误这里没有详细讨论，可参考 <a href="http://katemats.com/2011/11/13/distributed-systems-basics-handling-failure-fault-tolerance-and-monitoring/">http://katemats.com/2011/11/13/distributed-systems-basics-handling-failure-fault-tolerance-and-monitoring/</a> 了解相关的容错和监控知识。</p>

<p><strong>建设高性能可扩展的数据访问服务的几个方面</strong></p>

<p><em>访问</em></p>

<p>大部分简单的网络服务都使用LAMP模型，如Figure 1.5</p>

<p><img src="http://www.aosabook.org/images/distsys/simpleWeb.png" title="Figure 1.5: Simple web applications" alt="Figure 1.5: Simple web applications" /></p>

<p>当网站做大时，有两个主要挑战：扩展App Server提高访问的能力，扩展Database Server的访问能力。假设我们有TB级数据，每个用户只会随机访问其中很小的一部分，类似于图片存取服务中的例子，如Figure 1.7.</p>

<p><img src="http://www.aosabook.org/images/distsys/accessingData.png" alt="Figure 1.7: Accessing specific data" /></p>

<p>TB级的数据不能够完全加载到内存中，这样就会读磁盘。而内存访问速度要比顺序读磁盘快6倍，比随机读磁盘快100,000倍，后面的文章会讨论如何解决这一问题。</p>

<p><em>缓存</em></p>

<p>缓存是一个拥有短期记忆的内存，他有一定的空间大小限制，访问速度快于直接去磁盘数据。缓存可以在系统架构任何层次上使用，但一般见于紧靠前端的位置。当某个节点需要查找数据时，先查自己携带的局部缓存，如果命中则直接返回。</p>

<p><img src="http://www.aosabook.org/images/distsys/multipleCaches.png" alt="Figure 1.9: Multiple caches" /></p>

<p>当有很多节点时呢？假设每个节点只拥有自己的局部缓存，如果负载均衡器是随机分发请求的，就会导致同一个请求发到不同的节点，之前节点的缓存数据就浪费了，降低了缓存命中率。有两种方法可以解决这个问题：全局缓存 和 分布式缓存。</p>

<p><em>全局缓存</em></p>

<p>全局缓存即所有节点都使用同一个缓存空间，一般是增加一台服务器专门做这件事。如果缓存没有命中，如何查询原始数据，有两种解决方式：一是由缓存自己来查找原始数据，另一种是由请求端查找原始数据，这两张架构如下图：</p>

<p><img src="http://www.aosabook.org/images/distsys/globalCache1.png" alt="Figure 1.10: Global cache where cache is responsible for retrieval" /></p>

<p><img src="http://www.aosabook.org/images/distsys/globalCache2.png" alt="Figure 1.11: Global cache where request nodes are responsible for retrieval" /></p>

<p>大部分网络服务都用第一种方式，缓存本身可以管理获取和驱逐数据，防止数据层请求泛滥。然而第二种实现方式在某些场景下也很有道理，比如当经常访问较大的文件时，缓存服务器会因空间紧张而导致较低的命中率，这样与后端数据的连接也会导致系统效率低下，不如把缓存服务器专门存储一些全局上较热门的数据效率来的更高。需要注意的是，第二种方式需要请求发起端要理解缓存的驱逐策略。</p>

<p><em>分布式缓存</em></p>

<p>分布式缓存是只每个节点管理一部分缓存数据，不同于局部缓存的是，整个缓存是通过一致性哈希策略划分的，这样一个请求节点是很快能知道该去哪里查它所需要的数据的。这种情况下，一个节点如果需要数据，会向另一个节点请求查缓存，未命中再去查原始数据。分布式缓存只需要通过增加请求池内的节点数即可扩展缓存空间。</p>

<p>分布式缓存当丢失节点时会存在降低命中率的缺陷，一些分布式缓存系统通过增加多份拷贝来解决这个问题，但随之会引来更多的复杂性问题，如增删节点情况下的多份缓存如何维护等，所以这个问题基本上就是不去理它，查不到缓存直接查原始数据来替代。</p>

<p><img src="http://www.aosabook.org/images/distsys/distributedCaching.png" title="Figure 1.12: Distributed cache" alt="Figure 1.12: Distributed cache" /></p>

<p>比较著名的开源缓存有Memcached (<a href="http://memcached.org/">http://memcached.org/</a>) ，既可以作为局部缓存，也可以作为分布式缓存。此外Facebook使用多种类型的缓存来提高网站效率 (<a href="http://sizzo.org/talks/">&ldquo;Facebook caching and performance&rdquo;</a>). Facebook也使用全局缓存(<a href="http://www.facebook.com/note.php?note_id=39391378919">&ldquo;Scaling memcached at Facebook&rdquo;</a>)。</p>

<p><em>代理</em></p>

<p>代理服务器是一种中间件软件或硬件，用于接收客户端请求，并传递给后端服务，一般用于过滤请求，记录请求，或者对请求做转换、包装和压缩。</p>

<p><img src="http://www.aosabook.org/images/distsys/proxies.png" alt="Figure 1.13 Proxy server" /></p>

<p>当多个节点的大量请求到来时，代理可以从系统层面优化请求流量，比如把相似请求汇集到一起。比如多个节点发送同一个请求索要数据（littleB）时，如果通过代理访问数据，则这些请求可以归为同一个，我们只需要读磁盘一次就能完成任务，不过这样设计的代价是为了把请求合并，每个响应都需要有较高的一些延迟。代理有点类似于缓存，但它不存储数据，它只优化请求，如下图：</p>

<p><img src="http://www.aosabook.org/images/distsys/collapseRequests.png" alt="Figure 1.14: Using a proxy server to collapse requests" /></p>

<p>另一个用代理的方式是根据数据的存储地址接近性聚合请求，比如下图中会一次取出bigB用于响应三个请求。</p>

<p><img src="http://www.aosabook.org/images/distsys/collapseRequestsSpatial.png" alt="Figure 1.15: Using a proxy to collapse requests for data that is spatially close together" /></p>

<p>值得注意的是，你可以同时使用代理和缓存，但必须把缓存放在代理的前端，因为响应时间是根据最慢的一环来决定的，如果缓存放在代理后面，系统的平均响应时间至少是代理的响应时间，缓存的快速返回作用就无效了。</p>

<p>开源的代理系统很多，如<a href="http://www.squid-cache.org/">Squid</a>和<a href="https://www.varnish-cache.org/">Varnish</a>，把它们作为web服务器层的反向代理能够提高整体响应效率，降低大量处理客户端请求的工作。</p>

<p><em>索引</em></p>

<p>典型的就是倒排索引，可以对原始数据、数据库等建立，是一种增加存储空间和牺牲写入时间来换取快速查询的trade off。可以对同一份数据从不同角度建立索引，用于满足不同类型的数据过滤额查询。另外，可以通过嵌套索引（索引的索引），级联索引，粗粒度/细粒度的索引来降低对大量数据只建一个索引导致的索引数据过大问题。</p>

<p><em>负载均衡</em></p>

<p>负载均衡器可以允许多个请求端透明的访问多个具有相同功能的服务端，主要目的是为了处理高并发连接，并增加系统服务更多请求的扩展性，如下图：</p>

<p><img src="http://www.aosabook.org/images/distsys/loadBalancer.png" alt="Figure 1.18: Load balancer" /></p>

<p>负载均衡的策略有很多，比如随机选择一个节点、round robin，或者根据节点的CPU/内存利用率等。在复杂的系统中，还会存在级联的负载均衡，如下图：</p>

<p><img src="http://www.aosabook.org/images/distsys/multipleLoadBalancers.png" alt="Figure 1.19: Multiple load balancers" /></p>

<p>使用负载均衡的一个挑战是管理user-session相关数据，为了防止user-session被划分到不同服务器而造成session被割裂，不过目前这些问题基本都通过浏览器缓存、cookie和URL重写技术解决了。</p>

<p>负载均衡提供了准则函数用于测试系统中的节点是否健康，以便当某个节点不响应或者过载时将其从请求处理池中移除，利用系统中其他冗余节点进行服务。</p>

<p><em>队列</em></p>

<p>这里主要是探讨如何有效的管理写操作。当系统复杂时，数据常常需要写到不同服务器或索引的多个位置，因此是很耗时的，所以常常要通过队列将这些操作组织成异步处理的形式，提高效率。</p>

<p><img src="http://www.aosabook.org/images/distsys/synchronousRequest.png" alt="Figure 1.20: Synchronous request" /></p>

<p>同步的处理行为造成请求发生时，客户端必须等到服务端完成工作，这段时间不能进行其他工作；增加额外服务器不能解决这个问题，此外，如果服务端不可用或出错，上游客户端就会出错，客户端不能做到对错误处理透明化。</p>

<p><img src="http://www.aosabook.org/images/distsys/queues.png" alt="Figure 1.21: Using queues to manage requests" /></p>

<p>使用队列，可以让客户端递交写请求到队列后，服务端给一个应答句柄即返回，这样服务方式是异步的，客户端可以周期性检查任务状态，一旦完成再获取结果。同时，请求与应答结果在管理上是分离的，客户端在异步等待上一个结果完成前还可以去处理其他请求。</p>

<p>同时，队列对系统的错误处理提供了保护，例如可以创造一个鲁棒的队列用于重发响应失败的请求，这比把错误处理任务直接扔给客户端要好很多。</p>

<p>队列是在大型分布式系统下很基础的管理分布式通信的工具，相关的开源软件有<a href="http://www.rabbitmq.com/">RabbitMQ</a>，<a href="http://activemq.apache.org/">ActiveMQ</a>，<a href="http://kr.github.com/beanstalkd/">BeanstalkD</a>，偶尔也会使用<a href="http://zookeeper.apache.org/">Zookeeper</a>或者数据存储<a href="http://redis.io/">Redis</a>来完成</p>

<p><strong>原文来自：</strong>
<a href="http://www.aosabook.org/en/distsys.html">http://www.aosabook.org/en/distsys.html</a><p class='post-footer'>
            原文地址
            <a href='http://xuyuandong.github.io/blog/blog/2014/11/10/scalable-web-systems/'><a href="http://xuyuandong.github.io/blog/blog/2014/11/10/scalable-web-systems/">http://xuyuandong.github.io/blog/blog/2014/11/10/scalable-web-systems/</a></a><br/>
            &nbsp;written by <a href='http://xuyuandong.github.io/blog'>XuYuandong</a>
            &nbsp;posted at <a href='http://xuyuandong.github.io/blog'><a href="http://xuyuandong.github.io/blog">http://xuyuandong.github.io/blog</a></a>
            </p></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2014/11/06/matrix-factorization/">矩阵分解在广告、推荐技术中的应用</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-06T12:23:15+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:23 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>to be updated<p class='post-footer'>
            原文地址
            <a href='http://xuyuandong.github.io/blog/blog/2014/11/06/matrix-factorization/'><a href="http://xuyuandong.github.io/blog/blog/2014/11/06/matrix-factorization/">http://xuyuandong.github.io/blog/blog/2014/11/06/matrix-factorization/</a></a><br/>
            &nbsp;written by <a href='http://xuyuandong.github.io/blog'>XuYuandong</a>
            &nbsp;posted at <a href='http://xuyuandong.github.io/blog'><a href="http://xuyuandong.github.io/blog">http://xuyuandong.github.io/blog</a></a>
            </p></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2014/11/02/architecture/">程序化购买下的广告技术架构</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-02T12:21:01+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2014</span></span> <span class='time'>12:21 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>to be updated<p class='post-footer'>
            原文地址
            <a href='http://xuyuandong.github.io/blog/blog/2014/11/02/architecture/'><a href="http://xuyuandong.github.io/blog/blog/2014/11/02/architecture/">http://xuyuandong.github.io/blog/blog/2014/11/02/architecture/</a></a><br/>
            &nbsp;written by <a href='http://xuyuandong.github.io/blog'>XuYuandong</a>
            &nbsp;posted at <a href='http://xuyuandong.github.io/blog'><a href="http://xuyuandong.github.io/blog">http://xuyuandong.github.io/blog</a></a>
            </p></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2014/10/19/allocation/">流量分配与规划算法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-10-19T12:23:35+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:23 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>to be updated<p class='post-footer'>
            原文地址
            <a href='http://xuyuandong.github.io/blog/blog/2014/10/19/allocation/'><a href="http://xuyuandong.github.io/blog/blog/2014/10/19/allocation/">http://xuyuandong.github.io/blog/blog/2014/10/19/allocation/</a></a><br/>
            &nbsp;written by <a href='http://xuyuandong.github.io/blog'>XuYuandong</a>
            &nbsp;posted at <a href='http://xuyuandong.github.io/blog'><a href="http://xuyuandong.github.io/blog">http://xuyuandong.github.io/blog</a></a>
            </p></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2014/10/07/budget-smooth/">预算平滑与在线分配策略</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-10-07T12:22:43+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:22 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>to be updated<p class='post-footer'>
            原文地址
            <a href='http://xuyuandong.github.io/blog/blog/2014/10/07/budget-smooth/'><a href="http://xuyuandong.github.io/blog/blog/2014/10/07/budget-smooth/">http://xuyuandong.github.io/blog/blog/2014/10/07/budget-smooth/</a></a><br/>
            &nbsp;written by <a href='http://xuyuandong.github.io/blog'>XuYuandong</a>
            &nbsp;posted at <a href='http://xuyuandong.github.io/blog'><a href="http://xuyuandong.github.io/blog">http://xuyuandong.github.io/blog</a></a>
            </p></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2014/09/26/user-profile/">利用社交网络与行为定向建立用户模型</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-09-26T12:22:34+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:22 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>to be updated<p class='post-footer'>
            原文地址
            <a href='http://xuyuandong.github.io/blog/blog/2014/09/26/user-profile/'><a href="http://xuyuandong.github.io/blog/blog/2014/09/26/user-profile/">http://xuyuandong.github.io/blog/blog/2014/09/26/user-profile/</a></a><br/>
            &nbsp;written by <a href='http://xuyuandong.github.io/blog'>XuYuandong</a>
            &nbsp;posted at <a href='http://xuyuandong.github.io/blog'><a href="http://xuyuandong.github.io/blog">http://xuyuandong.github.io/blog</a></a>
            </p></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2014/09/07/statistics-ctr/">基于统计的CTR预估与实时计算</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-09-07T12:22:24+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:22 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>to be updated<p class='post-footer'>
            原文地址
            <a href='http://xuyuandong.github.io/blog/blog/2014/09/07/statistics-ctr/'><a href="http://xuyuandong.github.io/blog/blog/2014/09/07/statistics-ctr/">http://xuyuandong.github.io/blog/blog/2014/09/07/statistics-ctr/</a></a><br/>
            &nbsp;written by <a href='http://xuyuandong.github.io/blog'>XuYuandong</a>
            &nbsp;posted at <a href='http://xuyuandong.github.io/blog'><a href="http://xuyuandong.github.io/blog">http://xuyuandong.github.io/blog</a></a>
            </p></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2014/08/16/forcast/">高维度下的流量预估技术</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-16T12:20:26+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:20 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>Holter-Winter Model</strong></p>

<p><strong>Data Sampling</strong></p>

<p><strong>High-Dimensional Search Index</strong></p>

<p><strong>Forcast with Constrains</strong></p>

<p><strong>Summery</strong></p>

<p>to be updated<p class='post-footer'>
            原文地址
            <a href='http://xuyuandong.github.io/blog/blog/2014/08/16/forcast/'><a href="http://xuyuandong.github.io/blog/blog/2014/08/16/forcast/">http://xuyuandong.github.io/blog/blog/2014/08/16/forcast/</a></a><br/>
            &nbsp;written by <a href='http://xuyuandong.github.io/blog'>XuYuandong</a>
            &nbsp;posted at <a href='http://xuyuandong.github.io/blog'><a href="http://xuyuandong.github.io/blog">http://xuyuandong.github.io/blog</a></a>
            </p></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2014/08/05/bid-model/">浅析RTB广告中的出价模型</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-05T12:24:02+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:24 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>随着RTB广告模式越来越火热，DSP技术也开始被作为各广告网络公司的核心技术来重点研发；其中，我认为一个DSP在技术上与传统广告系统最明显的差别就是增加了一个实时出价模型。关于出价模型的比较可操作的学术论文比较少，一是因为技术比较新，二是因为确实是公司最最核心的技术，不会轻易披露。我在这里会根据已知的业界两家公司的出价技术，结合自己的认识和实践，总结性的介绍一下开发一个出价模型所涉及的技术路线和操作方法论。</p>

<p><strong>制定模型目标</strong></p>

<p>任何出价模型都是以盈利为目的的，可以以广告主的ROI为目标，或者以DSP平台收益最大化为目标；作为广告平台，从赚钱的角度，我们以收益最大化为目标：</p>

<p>$f = max \sum (cost_i - bid_i) * winning_rate_i$</p>

<p>有意思的是，这里winning_rate又是bid的正相关函数。这里cost可以认为是eCPM，如果从广告主ROI角度考虑可以认为是获得一个转化的收益，bid则是DSP对AdExchange的报价，即我们的出价，可以认为是获得一个转化的成本；</p>

<p>另外可以看到如下规律，出价bid越高，净收益越小，但胜出率越大；反之，出价bid越小，净收益越大，但胜出的概率却小了；因此，对一次竞价而言，存在一个最佳的出价，在净收益和胜出率中取得最佳平衡点，获取最大的有效真实收益。</p>

<p>这里没有提到的是，目标函数是有预算约束的，最优化过程中要在约束问题范围内求解，不过为了简化处理，我们暂时先忽略这一约束的存在。</p>

<p><strong>计算胜出率</strong></p>

<p>从上面的目标函数可以看出，对于特定上下文环境下的一次广告曝光竞拍机会，能够确定其胜出率对出价的关系函数是很重要的。胜出率和CTR一样受到多种因素的影响，最主要的影响因子可以认为是用户年龄、性别、兴趣等属性，以及广告位等流量来源和上下文属性。</p>

<p>我们可以把胜出率表示为p(winning_rate | bid, user, context)，而在计算最优出价时，最好是能够把user、context变量积分掉。不过在一般情况下是很难计算出这样一个winning_rate对bid的泛函关系的，工业界常用的方法是从历史竞价日志中挖掘出一个叫做bid landscape的数据查询模型，详细可以参考Yahoo的论文《Bid Landscape Forecasting in Online Ad Exchange Marketplace》。</p>

<p>从直观上理解，bid landscape就是一颗根据历史竞价日志中影响竞价的条件、出价、以及是否胜出建立的树形索引；其中，影响竞价的条件，如用户和上下文属性，构成了树枝节点，对于特定一条路径到达的叶子节点，其对应着该路径代表的竞价条件下bid与winning_rate的函数关系，一般用高斯分布来描述这个关系；所以，一条树枝和其叶子节点就管理着一个高斯分布，利用这个分布可以计算bid的大小对应着winning的概率。上述的论文还提到一个有价值的观点，即对于不充分统计的树枝可以合并成一个*节点，用于查询索引时做模糊匹配，可以解决数据稀疏问题。</p>

<p>业界其他关于直接谈论胜出率和bid关系的论文就比较少了，但是方法论如出一辙，都是通过查询历史数据来调节特定流量或人群下的基准出价。</p>

<p><strong>出价函数建模</strong></p>

<p>有了以上的建模基础，我们可以针对每个候选广告计算CTR，然后搜索一个最佳的bid，最后按照收益最大的目标向AdExchange报价并投放对应的广告。这个方法的问题主要在于计算效率还不够高，因此现实中会继续把问题做简化，在报价精度与效率之间做trade off。</p>

<p>下面我们换一个角度探讨一下如何计算出价。我们不去显示建立winning_rate与bid的关系，而是把他隐含在出价里面，认为bid ~ (ad, user, context)。这样，可以离线建立一个模型，对于特定的用户、上下文和广告，直接判别式的计算出出价。这种计算方法其实是和收益目标最大化方法等价的，差别在于实现中可以经过各种简化和粗算，下面就介绍一下业界两家著名DSP的计算方法：</p>

<p><em>M6D</em>
M6D是美国一家DSP公司，他们采取离线根据平均转化率avgCVR高低将用户划分成N个等级，每个等级被赋予一个基础出价；在线竞价过程中，先查找出该用户等级对应的基础出价avgBid，再根据实际投放广告和上下文，计算出真实转化率CVR，则最终出价为：</p>

<p>$bid = avgBid * (\frac{CVR}{avgCVR})^{\beta}$</p>

<p>这里 $\beta$ 一般是个阶梯函数，根据不同的CVR比值范围，跳跃性的取几个取值。这个模型可以看成是将出价因素分解为离线的用户基础出价和在线广告及上下文调整出价两部分，对winning_rate适配和收益目标的最大化体现在基础出价的制定和线上 $\beta$ 参数的调整。</p>

<p><em>一淘</em></p>

<p>一淘为了简化DSP出价的计算处理，提高报价效率，采用了只考虑流量属性估算出价，先报价后决策投放哪个广告的策略。我觉得这样做本身是有一定前提的：一是因为淘宝本身广告库极大，任何流量都能匹配出优质的广告，因此报价时考不考虑广告因素对最终结果影响不大；二是这样做等于把bid landscape只跟流量属性做关联，缓解了反馈数据的稀疏性问题。</p>

<p>在这一简化下，淘宝采用的是优化目标函数求解bid方法，先对AdExchange进行报价；如果竞价成功，则在AdExchange请求具体创意时，再对候选广告计算CVR，选择最佳创意。</p>

<p><strong>还是E&amp;E的问题</strong></p>

<p>在DSP向AdExchange报价这个任务中，面对的Explore&amp;Exploit问题更加突出，我们不但要面对CTR/CVR预估的冷启动，还要对新流量和新的竞争环境进行winning_rate的探索。一般是需要浪费一部分预算，对bid landscape覆盖不充分的流量进行报价，进一步探索出winning_rate，大体方法论上和CTR预估的E&amp;E差不多。</p>

<p>这里需要注意的是，探索的代价不只是浪费流量，同时需要浪费预算，这对于DSP的利润是有影响的（所以说搞不好DSP是要赔钱的）。一般市场上的DSP都采取谨慎的态度：或者控制出价公式，比如对用于Explore的出价要有另一套参数进行调控；或者控制流量，比如只对在DMP中能够匹配到user profile的流量进行报价，或者只在预算充分的情况下进行E&amp;E，并且要控制E&amp;E的pacing rate，探索过程将更加漫长。</p>

<p><strong>实践中的各种策略应对</strong></p>

<p><em>价格战</em></p>

<p>根据一淘披露的算法，会有一个bid_incr参数，用来调整预估出价与实际环境的bias，典型的应用就是价格战： $bid *= (1 + bid_incr)$</p>

<p><em>实时反馈</em></p>

<p>实时流可以及时调整bid landscape的准确率，反映环境的变化，对E&amp;E和预算控制是非常重要的，其实一切模型都应该考虑成有全量计算的和增量计算的两部分构成。</p>

<p><em>流量控制</em></p>

<p>主要目的是节约预算，使利润最大化，因此对于满足一定过滤条件的竞价机会（如：CTR低于一定阈值的情况），可以直接不竞价或出极低的价格。</p>

<p><em>频次控制</em></p>

<p>跟流量控制类似，防止短时间内对同类型的流量重复报价，用于节省预算。</p>

<p><em>广告隔离</em></p>

<p>在一些论文中，关于bid landscape以及如M6D的用户分级和基础出价都是针对每个广告计划独立制定的，这样可以更好的保护广告主的利益，使彼此的受众目标和投放数据做到隔离。这样做的缺点在于加大了数据的稀疏性，在条件允许下，我觉得把所有广告数据一起进行处理是更好的做法。</p>

<p>总结一下，出价模型并不像CTR预估一样纯粹，不能简单直接去hack model，系统性的支撑更为重要，技术上也更有挑战，效果的评估却也更加不易。<p class='post-footer'>
            原文地址
            <a href='http://xuyuandong.github.io/blog/blog/2014/08/05/bid-model/'><a href="http://xuyuandong.github.io/blog/blog/2014/08/05/bid-model/">http://xuyuandong.github.io/blog/blog/2014/08/05/bid-model/</a></a><br/>
            &nbsp;written by <a href='http://xuyuandong.github.io/blog'>XuYuandong</a>
            &nbsp;posted at <a href='http://xuyuandong.github.io/blog'><a href="http://xuyuandong.github.io/blog">http://xuyuandong.github.io/blog</a></a>
            </p></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2014/08/02/explore-sort/">广告在线投放中的排序与冷启动技术</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-02T12:21:21+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2014</span></span> <span class='time'>12:21 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>关于广告的在线投放技术，提及到策略和算法的东西可参考的并不像CTR预估那样多，原因主要还是和具体业务太相关，能够抽象出来的东西经过进一步简化，就比较少了；此外，由于学术圈比较难拿到真实数据，更难的是去做真实的大规模的实验，所以少了学术圈的推动，就难以热起来。但是，在工业界，线上策略对业务发展是非常重要的，并且会与工程、业务逻辑结合更加紧密，是公司里非常核心的技术。</p>

<p><strong>常见的扣费机制</strong></p>

<p>建立一个广告产品需要定义它的售卖对象、售卖方式和扣费机制（一种产品思维是把推荐也纳入到广告体系，甚至有人认为在移动互联网时代，可以把所有东西都认为是广告，即“产品即广告”；人们在消费信息，就是在消费广告，差异只在于这个信息是否有“buy”按钮，就是这条信息要不要触发扣费机制）。</p>

<p>首先，定义好售卖对象才能找到最匹配自己流量价值的广告主，定义好合适的售卖方式才能把广告主留住，帮广告主和自己找到共赢的合作方式。其中跟技术相关的就是扣费机制。按传统的几种方法来看，主要就是按CPM、CPC或者CPS来付费，对于常见的竞价广告系统来说，一般是在此基础上使用广义第二价格（GSP）计费。</p>

<p>刚接触广告的人一般看资料会误解为计费方式只有上面提到的几种，其实不是的，真正在商业领域会有各种各样不拘一格的广告扣费机制，核心目的是在提供流量资源（Supply）和产生的转化价值（Demand）之间找到双方认可的trade off；但是由于广告推广过程所涉及的多方（媒体、网络、广告主等）之间不能保证完全的信息透明，并且一旦涉及品牌效应和间接转化又无法量化衡量，所以才产生了或者偏向于Supply端、或者偏向于Demand端的扣费方式。</p>

<p>然后，我们在看一下竞价拍卖模式下的GSP扣费算法，排在第一位的成功竞拍者的扣费价格为出价第二高的价格加1个最小单位价格。对于广告来说呢？假设一个广告网络的竞价队列里同时存在以CPM/CPC/CPS扣费的广告，我们该如何排序？并如何计费呢？</p>

<p><strong>广告排序策略</strong></p>

<p>  <em>混合竞价</em></p>

<p>  上面提到一个很普遍存在的情况，即一个竞价队列中同时存在按CPM/CPC/CPS计费的广告，我们如何排序能够确保投放一个最优的广告呢？假设广告的出价都是广告主在预算了能够满足自己ROI前提下的价格，那么对于媒体或广告网络来说，从当前单次的曝光能够产生最大的收益的角度出发：<br/>
  CPM广告其收益为: Price{cpm} / 1000<br/>
  CPC广告其收益为: Price{cpc} * CTR <br/>
  CPS广告其收益为: Price{cps} * CTR * pCVR   <br/>
  我们将这三个可比拟的量统一称作eCPM，即effective CPM，其中CTR与pCVR是广告平台针对当前流量和当前投放的广告预估的点击率和点击后的转化率。</p>

<p>  <em>GSP计费一些讨论</em></p>

<p>  实际应用当中，不同的广告网络会对eCPM的计算有所变化，因为之前的公式是在流量资源被大量不同结算类型的广告主充分竞争情况下得出的结论，大家可以试想一下如果不满足这个条件，在GSP扣费原则下，会发生什么？对于天然CTR较低的广告位，会导致投CPC广告的客户居多，如果竞争不够充分，则出价高的广告主通过较低的GSP扣费就可以获得大量曝光；同理，对于天然CTR较高的广告位，投放CPM广告的客户可以利用较低的扣费赚取大量点击。</p>

<p>  此外，对于CPM广告，其决定排序的因素只有价格，所以广告主甚至可以出高价而不保证其广告创意对用户体验，这对媒体和广告网络的长期发展是极为不利的。因此，对不同计费类型的广告其eCPM计算可以略作修改的，一个常见的做法是：<br/>
$$
eCPM = Price * CTR^{\alpha} * pCVR^{\beta}
$$<br/>
其中，$ \alpha[cpm] = \alpha[cpc/cps] - 1, \beta[cpm/cpc] = \beta[cps] - 1 $ ，这里 $\alpha[cpc/cps]$ 和 $\beta[cps]$ 在默认条件下就是等于1的，可以通过微调 $\alpha, \beta$ 来控制CTR/CVR在不同类型计费广告中起的作用，从而让广告平台向用户体验好和对Demand端有利的广告有所倾斜。</p>

<p>  另外，对于GSP扣费，还有一个优美的统一公式，即：<br/>
$$
cost = Price * \frac{eCPM_2}{eCPM_1}
$$<br/>
无论何种类型的广告即排序顺序如何，都是可以套用的。这里还可以跟读者透露一个信息，即GSP只是绝大部分广告网络采样的扣费原则，目的是在按eCPM排序前提下，能够保证广告主自身无论如何调整出价，只要排名不变则其扣费就不会受到影响；这样，既能够保证广告网络的价格因素是稳定的，有利于把精力集中在受众定向的优化上，长期看还有利于广告网络整体竞争价格的上涨。</p>

<p><strong>冷启动问题</strong></p>

<p>按照上文的排序方案，一个直接的问题就是预估CTR或者CVR，但是无论是基于统计的方法还是基于模型的方法来预估CTR，前提是对候选广告有充分的投放样本可以参考。但是，实践中广告系统是高动态的，每日的新增广告比例还是很高的，这些没有投放记录的广告可以通过一些类似推荐中Content-based的方法估计出一个CTR分布，但是绝对不会很精确。因此，线上的投放策略一定要考虑到如何以最小的代价分配一些流量给新增广告，收集一些样本以便探索到新增广告的真实效果。</p>

<p>这方面在算法层面叫做“Explore &amp; Exploit”，即探索与开采，探索指浪费一部分流量投放非最优的新增广告进而收集其投放日志和分析它的投放效果，开采指在统计充分的广告中选择理论上最优的广告进行投放，两者之间是短期收入与长期利益的trade off。</p>

<p>这方面学术圈有大量的multi-arm bandit方面的论文从理论上讲如何做探索与开采，工业界比较好操作的策略大致我总结了以下三种：</p>

<p><strong>基于概率选择的E&amp;E策略</strong></p>

<p>长话短说，就是大家根据eCPM来排序，那么就根据eCPM来概率选择一个广告投放吧。优点是实现太简单了，能够做到大部分广告主都有消耗；缺点是毫无针对性，一是没有针对新增广告有目的的探索，二是没有针对短期收益做策略上的保障。</p>

<p><strong>基于置信度的E&amp;E策略</strong></p>

<p>一般是将广告按照曝光数量分为explore队列和exploit队列，然后设置一个explore比例，如果本次流量不需要做探索，则从exploit队列中选择最优广告进行投放；如果本次流量可以用来探索，则计算explore队列中每个广告的置信度，然后按置信度概率选择N个广告，再从N个广告中选择置信度最小（最需要探索的）进行投放。</p>

<p>这个策略来自雅虎的一篇论文《Exploitation and Exploration in a Performance based Contextual Advertising System》中被成为Confidence-based算法，其中置信度定义为 $tanh(frac{x}{b})$ ，x表示广告的曝光，b表示统计充分的阈值。</p>

<p>我认为该策略是有优点也存在未解决的问题的：优点在于策略的可控性，比如统计充分的阈值，探索的流量比例都是可调的；此外整个E&amp;E框架还可以进行扩展和修改，比如当前置信度概念只考虑了统计是否充分，如果不充分统计的广告其eCPM计算也有一定准确率，可以把eCPM等因素融入进去。这个策略的缺点在于，判断一个流量是否应该用于探索还是开采，纯粹是交给了随机数发生器，没有考虑当前的流量属性是否更适合探索还是开采，曝光是否充分的阈值也由经验决定，线上调参做实验成本高昂。</p>

<p><strong>基于Thompson采样的E&amp;E策略</strong></p>

<p>其实没有哪个E&amp;E框架能够在理论上证明是完美的，感觉这就是个实验科学话题，不过有的解决方案更偏工程化，有的解决方案会偏模型化。我认为Thompson采样策略是一个偏向于模型化的策略，它实际是个方法论，即CTR预估要估计出每个广告在当前流量下的CTR后验概率分布，然后按概率分布采样得到一个取值作为本次的预估CTR，整个排序和选择广告的过程是不需要有专门的探索或开采阶段的。</p>

<p>这看起来是个完美的解决方案，把任务直接交给CTR预估了。如果一个广告是统计充分的，那它的CTR后验概率分布形状应该非常尖锐（Sharp），统计期望CTR对应的概率密度应该非常大，这样采样的结果就大部分就是统计期望CTR；而如果一个广告是统计不充分的，那它的CTR后验概率分布形状将非常宽广（Wide），采样得到的结果会非常不集中，但随着样本积累越多，也会越来越接近统计平均。</p>

<p><em>Beta平滑</em></p>

<p>在使用统计方法做CTR预估的策略下，一般把统计似然的二项分布乘以先验beta分布做平滑，转化成后验beta分布 $B(a,b)$ ；所以，利用Thompson采样做CTR预估实际就是从beta分布中获得一个样本；当某个广告i被投放时，若有点击，则分布更新为 $B_i(a+1, b+1)$ ， 否则更新为 $B_i(a, b+1)$ ，下次采样则由更新后的分布决定；具体可以参考讲述统计平滑做CTR预估的博文。</p>

<p><em>LR模型</em></p>

<p>使用LR模型做CTR预估，CTR取值是由逻辑函数决定的，其统计不充分性来自于每个特征的学习样本是否充足；假设LR模型的损失函数使用L2正则化，则表示我们假设各维特征先验分布是高斯分布，学习模型时对每个特征权重的优化结果其实是特征的后验分布期望 $m_i$ ，我们还可以得到特征后验分布的标准差，如第i个特征 $ q_i = \sum_j<sup>n</sup> x_{ij}^2 p_j (1 - p_j) $ ，其中 $ p_j $ 是对样本j的CTR预测。</p>

<p>这样，整个Thompson采样过程其实就是对每个广告，取其每个特征i的分布 $N(m_i, q_i^{-1})$ ，对采样得到本次流量下该广告的特征采样值，进而计算该广告的CTR预估值。最终投放eCPM最大的，并按照投放结果是正样本还是负样本来更新每个特征的后验分布参数。</p>

<p>最后，需要补充的是，做好冷启动不能单纯看E&amp;E策略，还有更为重要的一环就是实时反馈，无论是统计还是模型，只有实时的把探索的效果反馈回系统，更正参数，才能引导系统向最优的方向运转，否则一切只是没有目标的低效率的探索而已。<p class='post-footer'>
            原文地址
            <a href='http://xuyuandong.github.io/blog/blog/2014/08/02/explore-sort/'><a href="http://xuyuandong.github.io/blog/blog/2014/08/02/explore-sort/">http://xuyuandong.github.io/blog/blog/2014/08/02/explore-sort/</a></a><br/>
            &nbsp;written by <a href='http://xuyuandong.github.io/blog'>XuYuandong</a>
            &nbsp;posted at <a href='http://xuyuandong.github.io/blog'><a href="http://xuyuandong.github.io/blog">http://xuyuandong.github.io/blog</a></a>
            </p></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/posts/2">&larr; Older</a>
    
    <a href="/blog/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/blog/2014/11/10/scalable-web-systems/">可扩展网站架构与分布式系统</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2014/11/06/matrix-factorization/">矩阵分解在广告、推荐技术中的应用</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2014/11/02/architecture/">程序化购买下的广告技术架构</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2014/10/19/allocation/">流量分配与规划算法</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2014/10/07/budget-smooth/">预算平滑与在线分配策略</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - XuYuandong -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
